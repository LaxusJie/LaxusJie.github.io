{"meta":{"title":"Laxus的海盗船","subtitle":"android developer","description":"劝君莫惜金缕衣，劝君惜取少年时","author":"Laxus(郝捷)","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-11-21T13:11:45.000Z","updated":"2017-11-28T16:40:43.577Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me本名郝捷，现居北京 android developer 目前致力于android项目架构设计，React Native 学习和研发中 轻度代码洁癖 热爱分享、喜欢交流技术 爱心满满的海贼迷 超级爱篮球、Curry和Wade粉 欢迎大家联系我交流和学习394692633@qq.com"},{"title":"categories","date":"2017-11-21T13:11:45.000Z","updated":"2017-11-21T13:12:26.093Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-21T13:10:45.000Z","updated":"2017-11-21T13:19:07.621Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"todo-mvvm-databinding源码分析","slug":"todo-mvvm-databinding源码分析","date":"2017-11-27T16:00:00.000Z","updated":"2017-11-28T16:11:20.670Z","comments":true,"path":"2017/11/28/todo-mvvm-databinding源码分析/","link":"","permalink":"http://yoursite.com/2017/11/28/todo-mvvm-databinding源码分析/","excerpt":"目的分析和学习官方mvvm框架的设计模式和数据绑定在其中的具体用法，制作一套符合当前公司业务场景的mvvm框架。其中也分析一下数据源在项目中的设计以及框架中单元测试的实施。","text":"目的分析和学习官方mvvm框架的设计模式和数据绑定在其中的具体用法，制作一套符合当前公司业务场景的mvvm框架。其中也分析一下数据源在项目中的设计以及框架中单元测试的实施。 设计模式MVVM框架中的ViewModel相比MVP框架中的Presenter起着类似的作用。两种框架结构的不同之处在于View分别与ViewModel或Presenter进行通信： 当MVVM框架中数据发生变化时会影响ViewModel的改变，View会自动更新库或框架。你不能直接通过ViewModel来修改View。 在这个项目中，你可以使用布局文件将ViewModel中的变量绑定到特定的UI元素上（如TextView或ImageView）。数据绑定可以确保View和ViewModel保持双向同步，如下图所示。 项目结构 项目相对比较简单，有以下几个模块 tasks 任务首页模块 taskdetail 任务详情模块 addedittask 添加任务模块 statistics 静态计数模块 data 数据模块 util 工具包 源码分析在这里不将每个模块具体剖析，用taskdetail作为代表模块分析mvvm框架的设计。 在TaskDetailActivity中获取Fragment和ViewModel对象来看TaskActivity的onCreate()方法， 通过findOrCreateViewFragment()和findOrCreateViewModel()来获取Fragment和ViewModel对象。 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... TaskDetailFragment taskDetailFragment = findOrCreateViewFragment(); mTaskViewModel = findOrCreateViewModel(); mTaskViewModel.setNavigator(this); // Link View and ViewModel taskDetailFragment.setViewModel(mTaskViewModel);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243@NonNullprivate TaskDetailViewModel findOrCreateViewModel() &#123; // In a configuration change we might have a ViewModel present. It&apos;s retained using the // Fragment Manager. @SuppressWarnings(&quot;unchecked&quot;) ViewModelHolder&lt;TaskDetailViewModel&gt; retainedViewModel = (ViewModelHolder&lt;TaskDetailViewModel&gt;) getSupportFragmentManager() .findFragmentByTag(TASKDETAIL_VIEWMODEL_TAG); if (retainedViewModel != null &amp;&amp; retainedViewModel.getViewmodel() != null) &#123; // If the model was retained, return it. return retainedViewModel.getViewmodel(); &#125; else &#123; // There is no ViewModel yet, create it. TaskDetailViewModel viewModel = new TaskDetailViewModel( getApplicationContext(), Injection.provideTasksRepository(getApplicationContext())); // and bind it to this Activity&apos;s lifecycle using the Fragment Manager. ActivityUtils.addFragmentToActivity( getSupportFragmentManager(), ViewModelHolder.createContainer(viewModel), TASKDETAIL_VIEWMODEL_TAG); return viewModel; &#125;&#125;@NonNullprivate TaskDetailFragment findOrCreateViewFragment() &#123; // Get the requested task id String taskId = getIntent().getStringExtra(EXTRA_TASK_ID); TaskDetailFragment taskDetailFragment = (TaskDetailFragment) getSupportFragmentManager() .findFragmentById(R.id.contentFrame); if (taskDetailFragment == null) &#123; taskDetailFragment = TaskDetailFragment.newInstance(taskId); ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), taskDetailFragment, R.id.contentFrame); &#125; return taskDetailFragment;&#125; Fragment中的数据绑定在TaskDetailFagment中的onCreateView()方法做了数据绑定，用setViewmodel()将ViewModel类和XML布局绑定到一起。 1234567891011121314@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.taskdetail_frag, container, false); TaskdetailFragBinding viewDataBinding = TaskdetailFragBinding.bind(view); viewDataBinding.setViewmodel(mViewModel); setHasOptionsMenu(true); return view;&#125; 我们再来看一下布局数据绑定片段 1234567891011&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; &lt;import type=&quot;android.view.View&quot; /&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;TaskDetailViewModel&quot; /&gt; &lt;/data&gt;&lt;/layout&gt; ViewModel 实现先来看一下子类TaskDetailViewModel实现，该类继承了TaskViewModel并提供了deleteTask和startEditTask两个对外方法供Fragment调用。这里的设计和MVP结构的P层是类似的，对外提供业务方法，内部实现具体业务。mTaskDetailNavigator接口是在TaskDetailActivity做具体实现的。12345678910111213141516171819202122232425262728293031323334public class TaskDetailViewModel extends TaskViewModel &#123; @Nullable private TaskDetailNavigator mTaskDetailNavigator; public TaskDetailViewModel(Context context, TasksRepository tasksRepository) &#123; super(context, tasksRepository); &#125; public void setNavigator(TaskDetailNavigator taskDetailNavigator) &#123; mTaskDetailNavigator = taskDetailNavigator; &#125; public void onActivityDestroyed() &#123; // Clear references to avoid potential memory leaks. mTaskDetailNavigator = null; &#125; /** * Can be called by the Data Binding Library or the delete menu item. */ public void deleteTask() &#123; super.deleteTask(); if (mTaskDetailNavigator != null) &#123; mTaskDetailNavigator.onTaskDeleted(); &#125; &#125; public void startEditTask() &#123; if (mTaskDetailNavigator != null) &#123; mTaskDetailNavigator.onStartEditTask(); &#125; &#125;&#125; 再来看父类TaskViewModel的实现。代码比较多，主要包含三个部分。 属性变量定义，为了实现双向绑定所以new的是ObservableField对象 数据相关方法，例如setTask()和getCompleted()等这些 通用业务操作方法，基本的封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public abstract class TaskViewModel extends BaseObservable implements TasksDataSource.GetTaskCallback &#123; public final ObservableField&lt;String&gt; snackbarText = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; title = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; description = new ObservableField&lt;&gt;(); private final ObservableField&lt;Task&gt; mTaskObservable = new ObservableField&lt;&gt;(); private final TasksRepository mTasksRepository; private final Context mContext; private boolean mIsDataLoading; public TaskViewModel(Context context, TasksRepository tasksRepository) &#123; mContext = context.getApplicationContext(); // Force use of Application Context. mTasksRepository = tasksRepository; // Exposed observables depend on the mTaskObservable observable: mTaskObservable.addOnPropertyChangedCallback(new OnPropertyChangedCallback() &#123; @Override public void onPropertyChanged(Observable observable, int i) &#123; Task task = mTaskObservable.get(); if (task != null) &#123; title.set(task.getTitle()); description.set(task.getDescription()); &#125; else &#123; title.set(mContext.getString(R.string.no_data)); description.set(mContext.getString(R.string.no_data_description)); &#125; &#125; &#125;); &#125; public void start(String taskId) &#123; if (taskId != null) &#123; mIsDataLoading = true; mTasksRepository.getTask(taskId, this); &#125; &#125; public void setTask(Task task) &#123; mTaskObservable.set(task); &#125; // &quot;completed&quot; is two-way bound, so in order to intercept the new value, use a @Bindable // annotation and process it in the setter. @Bindable public boolean getCompleted() &#123; Task task = mTaskObservable.get(); return task != null &amp;&amp; task.isCompleted(); &#125; public void setCompleted(boolean completed) &#123; if (mIsDataLoading) &#123; return; &#125; Task task = mTaskObservable.get(); // Notify repository and user if (completed) &#123; mTasksRepository.completeTask(task); snackbarText.set(mContext.getResources().getString(R.string.task_marked_complete)); &#125; else &#123; mTasksRepository.activateTask(task); snackbarText.set(mContext.getResources().getString(R.string.task_marked_active)); &#125; &#125; @Bindable public boolean isDataAvailable() &#123; return mTaskObservable.get() != null; &#125; @Bindable public boolean isDataLoading() &#123; return mIsDataLoading; &#125; // This could be an observable, but we save a call to Task.getTitleForList() if not needed. @Bindable public String getTitleForList() &#123; if (mTaskObservable.get() == null) &#123; return &quot;No data&quot;; &#125; return mTaskObservable.get().getTitleForList(); &#125; @Override public void onTaskLoaded(Task task) &#123; mTaskObservable.set(task); mIsDataLoading = false; notifyChange(); // For the @Bindable properties &#125; @Override public void onDataNotAvailable() &#123; mTaskObservable.set(null); mIsDataLoading = false; &#125; public void deleteTask() &#123; if (mTaskObservable.get() != null) &#123; mTasksRepository.deleteTask(mTaskObservable.get().getId()); &#125; &#125; public void onRefresh() &#123; if (mTaskObservable.get() != null) &#123; start(mTaskObservable.get().getId()); &#125; &#125; public String getSnackbarText() &#123; return snackbarText.get(); &#125; @Nullable protected String getTaskId() &#123; return mTaskObservable.get().getId(); &#125;&#125; 总结相对分析来看，这个项目代码比较简单没有什么难度，也有点失望。本来想看看官方项目有没有什么比较好的对ViewModel封装的方法，结果每个Activity都复制了一遍findOrCreateViewFragment()和findOrCreateViewModel()这两个方法，在Fragment中对数据绑定也没有做进一步的封装处理，心累…果然是基础框架教程，框架封装的事还是自己来搞吧。 附上官方github地址","categories":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/categories/源码分析/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}]},{"title":"Data binding 入坑笔记四列表适配器用法","slug":"Data binding 入坑笔记四列表适配器用法","date":"2017-11-23T16:00:00.000Z","updated":"2017-11-24T14:54:33.455Z","comments":true,"path":"2017/11/24/Data binding 入坑笔记四列表适配器用法/","link":"","permalink":"http://yoursite.com/2017/11/24/Data binding 入坑笔记四列表适配器用法/","excerpt":"Data binding 入坑笔记一入门篇Data binding 入坑笔记二进阶篇之双向绑定Data binding 入坑笔记三layout表达式详解 这一篇咱们来讲讲如何在RecyclerView 中的adapter 来使用Data binding，这个比较重要，因为毕竟各种样式的列表占据了app的半壁江山，我们一会儿先来说说原生怎么使用，然后再实战运用到一个比较火的开源项目BaseRecyclerViewAdapterHelper 上。","text":"Data binding 入坑笔记一入门篇Data binding 入坑笔记二进阶篇之双向绑定Data binding 入坑笔记三layout表达式详解 这一篇咱们来讲讲如何在RecyclerView 中的adapter 来使用Data binding，这个比较重要，因为毕竟各种样式的列表占据了app的半壁江山，我们一会儿先来说说原生怎么使用，然后再实战运用到一个比较火的开源项目BaseRecyclerViewAdapterHelper 上。 加载布局方式在讲适配器之前我们先来说一下DataBindingUtil加载布局的两种方式 普通加载1DataBindingUtil.setContentView(this, R.layout.activity_layout); 动态加载123View itemView = LayoutInflater.from(context) .inflate(layoutId, viewGroup, false);DataBindingUtil.bind(itemView); 或直接调用inflate方法加载布局 12DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent); 我们加载列表时在adapter中就用到了动态加载 原生使用方法先来看ViewHolder我们在构造中用DataBindingUtil的bind方法将view绑定，然后提供一个bind方法可以让每个item绑定实体 123456789101112public static class UserHolder extends RecyclerView.ViewHolder &#123; private UserItemBinding mBinding; public UserHolder(View itemView) &#123; super(itemView); mBinding = DataBindingUtil.bind(itemView); &#125; public void bind(@NonNull User user) &#123; mBinding.setUser(user); &#125;&#125; 再来看adapter的实现，我们现在onCreateViewHolder中获取view，然后在onBindViewHolder 中绑定数据，搞定 12345678910111213141516171819202122public class UserAdapter extends RecyclerView.Adapter&lt;UserAdapter.UserHolder&gt; &#123; @NonNull private List&lt;User&gt; mUsers; @Override public UserHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View itemView = LayoutInflater.from(viewGroup.getContext()) .inflate(R.layout.user_item, viewGroup, false); return new UserHolder(itemView); &#125; @Override public void onBindViewHolder(UserHolder holder, int position) &#123; holder.bind(mUsers.get(position)); &#125; @Override public int getItemCount() &#123; return mUsers.size(); &#125;&#125; 查看源码 在开源框架中用法我们以BaseRecyclerViewAdapterHelper为例，在不改底层框架的情况下我们可以这么用，当然如果嫌每次绑定很麻烦我们可以将开源库引进来改源码，把绑定动作放到底层去 1234567891011121314public class DiscussAdapter extends BaseQuickAdapter&lt;DiscussEntity, BaseViewHolder&gt; &#123; FragmentDiscussItemBinding binding; public DiscussAdapter() &#123; super(R.layout.fragment_discuss_item, null); &#125; @Override protected void convert(BaseViewHolder helper, DiscussEntity item) &#123; binding = DataBindingUtil.bind(helper.itemView); binding.setDiscuss(item); &#125;&#125;","categories":[{"name":"Android Data Binding","slug":"Android-Data-Binding","permalink":"http://yoursite.com/categories/Android-Data-Binding/"}],"tags":[{"name":"Data Binding","slug":"Data-Binding","permalink":"http://yoursite.com/tags/Data-Binding/"}]},{"title":"Data binding 入坑笔记三layout表达式详解","slug":"Data binding 入坑笔记三layout表达式详解","date":"2017-11-20T16:00:00.000Z","updated":"2017-11-21T13:59:29.025Z","comments":true,"path":"2017/11/21/Data binding 入坑笔记三layout表达式详解/","link":"","permalink":"http://yoursite.com/2017/11/21/Data binding 入坑笔记三layout表达式详解/","excerpt":"Data binding 入坑笔记一入门篇Data binding 入坑笔记二进阶篇之双向绑定 前两篇介绍了基础知识和双向绑定，今天我们来详细剖析一下layout语法规则，以便能灵活使用data binding","text":"Data binding 入坑笔记一入门篇Data binding 入坑笔记二进阶篇之双向绑定 前两篇介绍了基础知识和双向绑定，今天我们来详细剖析一下layout语法规则，以便能灵活使用data binding 表达式概览xml里支持使用以下表达式 数学 +`` - ``/`` *`` % 字符串连接 + 逻辑 &amp;&amp; || 二进制&amp;`` | ``^ 一元运算 +`` -`` !`` ~ 移位 &gt;&gt;`` &gt;&gt;&gt;`` &lt;&lt; 比较 ==`` &gt;`` &lt; ``&gt;= ``&lt;= instanceof 分组() null Cast 方法调用 数据访问 [] 三元运算 ?: 暂不支持以下表达式 this super new 显式泛型调用 表达式运用变量先来复习一下基础变量的使用，变量的使用分为变量给控件赋值和控件给变量赋值两种 变量给控件赋值1android:text=&quot;@&#123;student.name&#125;&quot; 控件给变量赋值（具体请参考双向绑定）1android:text=&quot;@=&#123;student.name&#125;&quot; 避免空指针data binding会自动帮助我们进行空指针的避免，比如说@{student.name}，如果name是null的话，student.name则会被赋默认值（null）。int的话，则是0。 空运算符1android:text=&quot;@&#123;user.firstName ?? user.lastName&#125;&quot; 这个操作等价于 1android:text=&quot;@&#123;user.displayName != null ? user.firstName : user.lastName&#125;&quot; 显隐控制首先在 xml 的 data 节点中引用View123&lt;data&gt; &lt;import type=&quot;android.view.View&quot;/&gt;&lt;/data&gt; 然后设置visibility1android:visibility=&quot;@&#123;student.boy ? View.VISIBLE : View.INVISIBLE&#125;&quot; 静态方法调用首先定义一个静态方法 1234567891011public class StringUtil &#123; /** * 实现文字倒序 * @param text 文字 * @return 倒序文字 */ public static String reverseString(String text) &#123; StringBuffer stringBuffer = new StringBuffer(text); return stringBuffer.reverse().toString(); &#125;&#125; 然后在 xml 的 data 节点中引用该类 123&lt;data&gt; &lt;import type=&quot;com.jie.databindingsimple.StringUtil&quot; /&gt;&lt;/data&gt; 最后是方法的调用 1android:text=&quot;@&#123;StringUtil.reverseString(student.name)&#125;&quot; 监听方法调用控件常用的监听都可以用事件绑定来搞定，比如以下这几种 android:onClick android:onLongClick android:onTextChanged… 常规调用方法首先在 xml 的 data 节点中添加变量，我这里是把当前activity对象添加进来123&lt;data&gt; &lt;variable name=&quot;activity&quot; type=&quot;com.jie.databindingsimple.LayoutActivity&quot;/&gt;&lt;/data&gt; 引用变量后别忘了在oncreate方法中绑定变量123ActivityLayoutBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_layout);binding.setActivity(this); 最后在控件中绑定事件123&lt;EditText... android:hint=&quot;事件监听，请输入文字&quot; android:onTextChanged= &quot;@&#123;activity::onTextChanged&#125;&quot;/&gt; 其他事件同理 Lambda表达式在xml中我们还可以应用lambda表达式来书写 1android:onClick=&quot;@&#123;(view) -&gt; activity.onTextClick(view)&#125;&quot; 统计一下事件监听表达的用法由此可见事件监听绑定有很多种用法，我们在项目中最好统一规范应用其中一种，避免个性化1234android:onClick=&quot;onTextClick&quot;android:onClick=&quot;@&#123;(view) -&gt; activity.onTextClick(view)&#125;&quot;android:onClick=&quot;@&#123;activity::onTextClick&#125;&quot;android:onClick=&quot;@&#123;activity.onTextClick&#125;&quot; 资源数据在xml中我们可以根据变量动态设置数值，比如这样 1android:padding=&quot;@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;&quot; 还可以拼接变量数据，比如这样 1android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot; 表达式链重复的表达式 123&lt;ImageView android:visibility=“@&#123;isVisible ? View.VISIBLE : View.GONE&#125;”/&gt;&lt;TextView android:visibility=“@&#123;isVisible ? View.VISIBLE : View.GONE&#125;”/&gt;&lt;CheckBox android:visibility=&quot;@&#123;isVisible ? View.VISIBLE : View.GONE&#125;&quot;/&gt; 可以简化成下面这样 1234&lt;ImageView aandroid:id=&quot;@+id/image&quot; android:visibility=&quot;@&#123;isVisible ? View.VISIBLE : View.GONE&#125;&quot;/&gt;&lt;TextView android:visibility=&quot;@&#123;image.visibility&#125;&quot;/&gt;&lt;CheckBox android:visibility=&quot;@&#123;image.visibility&#125;&quot;/&gt; 注意，id起名有一个bug，不能有下划线_否则会报错 Includeinclude核心在bind属性，可以绑定include里layout的变量，先看主布局 123456789&lt;data&gt; &lt;variable name=&quot;btnText&quot; type=&quot;String&quot; /&gt;&lt;/data&gt;&lt;LinearLayout...&gt; &lt;include layout=&quot;@layout/layout_button&quot; bind:btnText=&quot;@&#123;btnText&#125;&quot;/&gt;&lt;/LinearLayout&gt; 再看子布局，可见父布局用bind属性将btnText绑定了值，然后子布局进行赋值 123456789101112&lt;data&gt; &lt;variable name=&quot;btnText&quot; type=&quot;String&quot;/&gt;&lt;/data&gt;&lt;LinearLayout...&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; android:onClick=&quot;btnClick&quot; android:text=&quot;@&#123;btnText&#125;&quot;/&gt;&lt;/LinearLayout&gt; 注意的一点是，被include的布局必须顶层是一个ViewGroup，目前Data Binding的实现，如果该布局顶层是一个View，而不是ViewGroup的话，binding的下标会冲突（被覆盖），从而产生一些预料外的结果。 Viewstubs在xml中添加ViewStub标签 1234&lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout=&quot;@layout/view_stub&quot; ... /&gt; ViewStub比较特殊，在被实际inflate前是不可见的，所以使用了特殊的方案，用了final的ViewStubProxy来代表它，并监听了ViewStub.OnInflateListener 12345678binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; ViewStubBinding binding = DataBindingUtil.bind(inflated); User user = new User(&quot;Laxus&quot;, &quot;J&quot;); binding.setUser(user); &#125;&#125;); 总结讲到这里layout所有表达式的用法基本全了，包含了各种各样的应用场景，基本可以告别了在代码中获取view对象来设置监听方法和赋值，从而避免了大量的冗余代码，回去可以狂删代码了。下一节我们来说说Data Binding在Recycleview中的用法。 参考代码地址点这里","categories":[{"name":"Android Data Binding","slug":"Android-Data-Binding","permalink":"http://yoursite.com/categories/Android-Data-Binding/"}],"tags":[{"name":"Data Binding","slug":"Data-Binding","permalink":"http://yoursite.com/tags/Data-Binding/"}]},{"title":"Data binding 入坑笔记二进阶篇之双向绑定","slug":"Data binding 入坑笔记二进阶篇之双向绑定","date":"2017-11-18T16:00:00.000Z","updated":"2017-11-21T13:59:42.445Z","comments":true,"path":"2017/11/19/Data binding 入坑笔记二进阶篇之双向绑定/","link":"","permalink":"http://yoursite.com/2017/11/19/Data binding 入坑笔记二进阶篇之双向绑定/","excerpt":"Data binding 入坑笔记一入门篇 上一篇介绍了Data binding的基础用法，你可能会想这也太基础了，只支持前置数据的绑定，一旦数据变化了UI都监听不到。不要着急，这一篇就来讲到databinding的双向绑定用法。 举个例子我们用一个输入控件EditText和一个文本控件TextView来举个栗子，我们想要在TextView要获取文本框内容，原始写法首先获取两个控件的对象，然后设置输入框监听对象，最后赋值给TextView做显示，算了算需要写三步呢","text":"Data binding 入坑笔记一入门篇 上一篇介绍了Data binding的基础用法，你可能会想这也太基础了，只支持前置数据的绑定，一旦数据变化了UI都监听不到。不要着急，这一篇就来讲到databinding的双向绑定用法。 举个例子我们用一个输入控件EditText和一个文本控件TextView来举个栗子，我们想要在TextView要获取文本框内容，原始写法首先获取两个控件的对象，然后设置输入框监听对象，最后赋值给TextView做显示，算了算需要写三步呢 我们来看看Data Binding的代码，只需要把对象绑定进去就好了12345678910public class TwowayActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_twoway); ActivityTwowayBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_twoway); binding.setStudent(new Student()); &#125;&#125; 1234567891011121314151617181920212223&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;student&quot; type=&quot;com.jie.databindingsimple.entity.Student&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;请输入内容&quot; android:text=&quot;@=&#123;student.name&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;student.name&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Observable BindingData Binding本身是不支持双向绑定的，我们想要实现双向绑定首先要改造一下实体类。让实体类继承BaseObservable，来看例子123456789101112131415161718192021222324public class Student extends BaseObservable &#123; private String name; private String className; @Bindable public String getName() &#123; return name; &#125; @Bindable public String getClassName() &#123; return className; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public void setClassName(String className) &#123; this.className = className; notifyPropertyChanged(BR.className); &#125;&#125; BR是编译阶段生成的一个类，功能与 R.java 类似，用 @Bindable标记过 getter方法会在BR中生成一个静态常量。1234567public class BR &#123; public static final int _all = 0; public static final int className = 1; public static final int name = 2; public static final int student = 3; public static final int user = 4;&#125; 在setter方法里我们需要用notifyPropertyChanged方法来更新对象。 还有另一种适用于POJO的写法，这种写法不需要继承BaseObservable，不过每个成员变量都要new一个ObservableField对象。12345public class Teacher &#123; public final ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; className = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; xml写法如果想在输入的时候给变量赋值，则需要用到@={}这个操作符，{}里面是我们想要赋值的对象12345&lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;请输入内容&quot; android:text=&quot;@=&#123;student.name&#125;&quot;/&gt; 原理解析InverseBindingListener是事件发生时触发的监听器，所有双向绑定，最后都是通过这个接口来observable改变的，各种监听，比如TextWatcher、OnCheckedChange，都是间接通过这个接口来通知的。在ActivityTwowayBinding的源码中我们可以找到这个方法片段。1234567891011121314151617181920212223// values// listeners// Inverse Binding Event Handlersprivate android.databinding.InverseBindingListener mboundView1androidTextAttrChanged = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of student.name // is student.setName((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(mboundView1); // localize variables for thread safety // student com.jie.databindingsimple.entity.Student student = mStudent; // student.name java.lang.String studentName = null; // student != null boolean studentJavaLangObjectNull = false; studentJavaLangObjectNull = (student) != (null); if (studentJavaLangObjectNull) &#123; student.setName(((java.lang.String) (callbackArg_0))); &#125; &#125;&#125;; 我们通过java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(mboundView1);获取到EditText上输入的值，来看看getTextString方法1234@InverseBindingAdapter(attribute = &quot;android:text&quot;, event = &quot;android:textAttrChanged&quot;)public static String getTextString(TextView view) &#123; return view.getText().toString();&#125; InverseBindingAdapter用于关联某个用于接收View变更的方法，有两个参数attribute描述和event事件，获取到数据后我们拿到student对象，然后给他赋值student.setName(((java.lang.String) (callbackArg_0))); 属性改变监听如果有两个输入框，我们要监听输入对象的改变怎么办，如下： 我们可以利用Observable中的addOnPropertyChangedCallback来实现。先来看看Observable类，里面有添加回调、删除回调等方法。1234567891011121314package android.databinding;public interface Observable &#123; void addOnPropertyChangedCallback(Observable.OnPropertyChangedCallback var1); void removeOnPropertyChangedCallback(Observable.OnPropertyChangedCallback var1); public abstract static class OnPropertyChangedCallback &#123; public OnPropertyChangedCallback() &#123; &#125; public abstract void onPropertyChanged(Observable var1, int var2); &#125;&#125; 在onCreate中实现添加callback123456789101112131415161718192021@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_twoway); ActivityTwowayBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_twoway); Student student = new Student(); binding.setStudent(student); student.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123; @Override public void onPropertyChanged(Observable observable, int i) &#123; switch (i) &#123; case BR.name: Toast.makeText(TwowayActivity.this, &quot;name&quot;, Toast.LENGTH_SHORT).show(); break; case BR.className: Toast.makeText(TwowayActivity.this, &quot;classname&quot;, Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;);&#125; 双向绑定场景范围目前双向绑定仅支持如text，checked，year，month，hour，rating，progress等绑定。 完整代码看这里","categories":[{"name":"Android Data Binding","slug":"Android-Data-Binding","permalink":"http://yoursite.com/categories/Android-Data-Binding/"}],"tags":[{"name":"Data Binding","slug":"Data-Binding","permalink":"http://yoursite.com/tags/Data-Binding/"}]},{"title":"Data binding 入坑笔记一入门篇","slug":"Data binding 入坑笔记一入门篇","date":"2017-11-17T16:00:00.000Z","updated":"2017-11-21T13:58:56.337Z","comments":true,"path":"2017/11/18/Data binding 入坑笔记一入门篇/","link":"","permalink":"http://yoursite.com/2017/11/18/Data binding 入坑笔记一入门篇/","excerpt":"数据绑定已经推出两年多的时间了，是时候下一波水了，边学习边记录一下实战步骤以及踩过得一些坑。 什么是Data bindingData Binding，顾名思义，数据绑定，是Google对MVVM在Android上的一种实现，可以直接绑定数据到xml中，并实现自动刷新。现在最新的版本还支持双向绑定，尽管使用场景不是那么多。 Data Binding可以提升开发效率（节省很多以往需要手写的java代码），性能高（甚至超越手写代码），功能强（强大的表达式支持）。","text":"数据绑定已经推出两年多的时间了，是时候下一波水了，边学习边记录一下实战步骤以及踩过得一些坑。 什么是Data bindingData Binding，顾名思义，数据绑定，是Google对MVVM在Android上的一种实现，可以直接绑定数据到xml中，并实现自动刷新。现在最新的版本还支持双向绑定，尽管使用场景不是那么多。 Data Binding可以提升开发效率（节省很多以往需要手写的java代码），性能高（甚至超越手写代码），功能强（强大的表达式支持）。 准备环境保证接入的项目gradle插件版本不低于 1.5.0-alpha1： 1classpath &apos;com.android.tools.build:gradle:1.5.0&apos; 在对应模块（Module）的build.gradle文件添加如下配置 123dataBinding &#123; enabled true&#125; 布局文件要使用Data Binding首先xml文件有了以下变化，他的根节点变成了layout，里面包含一个data节点和原根节点LinearLayout，其中这个data是用来绑定数据的。 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;!--这是原根节点--&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 在data内可以利用variable声明变量，里面有两个属性name和type，name是变量的名字，type是变量的类型。(这里的User是一个实体类，下面说) 123&lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;&lt;/data&gt; 也可以把类型提出来用import导入 1234&lt;data&gt; &lt;import type=&quot;com.example.User&quot; /&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot; /&gt;&lt;/data&gt; 基础类型可以直接使用，无需import 1&lt;variable name=&quot;userName&quot; type=&quot;String&quot; /&gt; 配置好布局文件后，IDE会根据xml文件的名称自动生成一个DataBinding类用于数据绑定，命名规则如下 1activity_main.xml -&gt; ActivityMainBinding 数据对象POJO类对象User，这种类型的对象具有从不改变的数据。在应用程序中，数据是一次读取，此后从不更改，这是很常见的。 12345678public class User &#123; public final String firstName; public final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 也可以使用JavaBean形式 1234567891011121314public class User &#123; private final String firstName; private final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125;&#125; 绑定数据修改Activity中的onCreate方法，用DataBindingUtil.setContentView替代原来的setContentView方法从而实现数据绑定,创建user对象，通过binding.setUser(user)从而实现数据绑定 123456789private User user;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); user = new User(&quot;Laxus&quot;, &quot;J&quot;); binding.setUser(user);&#125; 值得一提的是binding.setUser(user)方法是由布局中的变量名自动生成的get 、 set方法 123&lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;&lt;/data&gt; 如果我们声明了一些基础变量，ActivityMainBinding也会相应的生成get 、 set方法 1234&lt;data&gt; &lt;variable name=&quot;firstName&quot; type=&quot;String&quot; /&gt; &lt;variable name=&quot;lastName&quot; type=&quot;String&quot; /&gt;&lt;/data&gt; 12setFirstName(String firstName);setLastName(String lastName); 使用数据现在我们就可以在xml的控件中使用数据绑定了 1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.lastName&#125;&quot; /&gt; 查看完整代码","categories":[{"name":"Android Data Binding","slug":"Android-Data-Binding","permalink":"http://yoursite.com/categories/Android-Data-Binding/"}],"tags":[{"name":"Data Binding","slug":"Data-Binding","permalink":"http://yoursite.com/tags/Data-Binding/"}]},{"title":"Android中AOP实践之三AspectJ解析篇","slug":"Android中AOP实践之三AspectJ解析篇","date":"2017-11-11T16:00:00.000Z","updated":"2017-11-21T14:02:40.902Z","comments":true,"path":"2017/11/12/Android中AOP实践之三AspectJ解析篇/","link":"","permalink":"http://yoursite.com/2017/11/12/Android中AOP实践之三AspectJ解析篇/","excerpt":"介绍AspectJ是Java的一个简单实用的面向方面的扩展。通过几个新的构造，AspectJ提供了对一系列横切关注的模块化实现的支持。 在现有的Java开发项目中采用AspectJ可能是一个简单而且增量的任务。一条路径是从开发方面开始，继续使用生产方面，然后在使用AspectJ建立经验之后再使用方面。采用也可以遵循其他途径。例如，一些开发人员将从马上使用生产方面受益。其他人可能几乎可以立即编写干净的可重用方面。 AspectJ支持基于名称和基于属性的横切。使用基于名称的横切的方面倾向于影响少数其他类。但是，尽管规模较小，但与普通的Java实现相比，它们通常可以消除显着的复杂性。使用基于属性的横切的方面可以具有小规模或大规模。 使用AspectJ会导致横切关注的干净模块化的实现。当作为AspectJ方面编写时，横切关注的结构是明确的且易于理解的。方面也是高度模块化的，使得开发横切功能的即插即用实现成为可能。","text":"介绍AspectJ是Java的一个简单实用的面向方面的扩展。通过几个新的构造，AspectJ提供了对一系列横切关注的模块化实现的支持。 在现有的Java开发项目中采用AspectJ可能是一个简单而且增量的任务。一条路径是从开发方面开始，继续使用生产方面，然后在使用AspectJ建立经验之后再使用方面。采用也可以遵循其他途径。例如，一些开发人员将从马上使用生产方面受益。其他人可能几乎可以立即编写干净的可重用方面。 AspectJ支持基于名称和基于属性的横切。使用基于名称的横切的方面倾向于影响少数其他类。但是，尽管规模较小，但与普通的Java实现相比，它们通常可以消除显着的复杂性。使用基于属性的横切的方面可以具有小规模或大规模。 使用AspectJ会导致横切关注的干净模块化的实现。当作为AspectJ方面编写时，横切关注的结构是明确的且易于理解的。方面也是高度模块化的，使得开发横切功能的即插即用实现成为可能。 基础知识Join point 连接点是指程序中可能作为代码注入目标的特定的点，例如一个方法调用或者方法入口。程序中连接点有很多，下面做一个表格一一指出：| Join Points | 定义 | 解释 || ——————— | :—-: | ———————: || method call | 调用方法 | 一般在执行某个方法前会先调用该方法 || method execution | 执行方法 | 这个点是已经执行到了方法的内部 || constructor call | 调用构造方法 | 同调用方法 || constructor execution | 执行构造方法 | 同执行方法 || field get | 获取参数 | 比如获取某个变量的值，get() || field set | 设置参数 | 比如设置某个变量的值，int num = 3 || pre-initialization | 预初始化 | 在第一次初始化前会预初始化 || initialization | 初始化 | 初始化类的时候会执行 || static initialization | 静态初始化 | 静态块或静态类初始化的时候会执行 || handler | 异常处理 | || advice execution | 通知执行 | | //这里可以用一个例子来演示一下所有的连接点 Pointcut 切入点一个程序中会有很多JPoint连接点，但不一定我们都要去关注。那么我们可以选择我们需要的点来作为切入点。 我们利用Pointcut的功能来筛选出对我们有用的点作为切入，pointcut有一套专门的语法，只要搞懂他后面就不愁了。 一个例子12345678@Pointcut(&quot;within(@com.jie.aoptest.aop.DebugLog *)&quot;)public void withinAnnotatedClass() &#123;&#125;@Pointcut(&quot;execution(!synthetic * *(..)) &amp;&amp; withinAnnotatedClass()&quot;)public void methodInsideAnnotatedType() &#123;&#125;@Pointcut(&quot;execution(@com.jie.aoptest.aop.DebugLog * *(..)) || methodInsideAnnotatedType()&quot;)public void method() &#123;&#125; 这个例子表明切入点在DebugLog类中所有执行方法的点，这里用到了within和execution两个指示符，within用于匹配指定类型内的方法执行，而exection则用于匹配方法执行的连接点。有synthetic标记的field和method是class内部使用的，正常的源代码里不会出现synthetic field。 切入点指示符常用指示符| 指示符 | 说明 || ———– | :————————————–: || execution | 用于匹配方法执行的连接点 || within | 用于匹配指定类型内的方法执行 || this： | 用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配 || target | 用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配 || args | 用于匹配当前执行的方法传入的参数为指定类型的执行方法 || @within | 用于匹配所以持有指定注解类型内的方法 || @target | 用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解 || @args | 用于匹配当前执行的方法传入的参数持有指定注解的执行 || @annotation | 用于匹配当前执行方法持有指定注解的方法 | AspectJ切入点支持的切入点指示符还有： call、get、set、preinitialization、staticinitialization、initialization、handler、adviceexecution、withincode、cflow、cflowbelow、if、@this、@withincode，感兴趣的可以了解，就不一一说明了。 类型匹配语法先来看一下AspectJ类型匹配的通配符 *：匹配任何数量字符； ..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数。 +：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。接下来看一下具体匹配表达式类型 注解：可选，方法上持有的注解，如@Deprecated； 修饰符：可选，如public、protected； 返回值类型：必填，可以是任何类型模式；“*”表示所有类型； 类型声明：可选，可以是任何类型模式； 方法名：必填，可以使用“*”进行模式匹配； 参数列表：“()”表示方法没有任何参数；“(..)”表示匹配接受任意个参数的方法，“(..,java.lang.String)”表示匹配接受java.lang.String类型的参数结束，且其前边可以接受有任意个参数的方法；“(java.lang.String,..)” 表示匹配接受java.lang.String类型的参数开始，且其后边可以接受任意个参数的方法；“(*,java.lang.String)” 表示匹配接受java.lang.String类型的参数结束，且其前边接受有一个任意类型参数的方法； 异常列表：可选，以“throws 异常全限定名列表”声明，异常全限定名列表如有多个以“，”分割，如throws java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException。组合切入点表达式AspectJ使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。常用场景举例 Advice通知参数前面已经介绍了Join point 连接点和 Pointcut 切入点，如果基本掌握了的话那么恭喜你内功已经修炼7成了。 我们成功设置好切入点后需要获取通知来执行要切入的代码片段，这里的通知相当于钩子/回调方法，在程序执行到JPoint时候会调起通知，接下来就介绍一下获取通知的方式。 Advice通知有三种类型 类型 说明 before() 是指在JPoint之前可以执行一些操作 after() 是指在JPoint之后可以执行一些操作 around() 环绕JPoint执行操作，它包含了前后两个过程，使用这种类型需要手动调用procees方法来执行原操作 来看一个例子我们来用检测是否登录做一个例子这个是检查登录的注解1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface CheckLogin &#123;&#125; 先用before和after两个类型来做一个测试123456789101112131415@Pointcut(&quot;execution(@com.jie.aoptest.aop.CheckLogin * *(..))&quot;)public void methodAnnotated() &#123;&#125;@Before(&quot;methodAnnotated()&quot;)public void beforeMethod(ProceedingJoinPoint joinPoint) &#123; Log.d(&quot;aspect&quot;, &quot;beforeMethod&quot;); Log.d(&quot;login&quot;, &quot;请您登录&quot;); Toast.makeText(App.getAppContext().getCurActivity(), &quot;请您登录&quot;, Toast.LENGTH_SHORT).show();&#125;@After(&quot;methodAnnotated()&quot;)public void afterMethod(ProceedingJoinPoint joinPoint) &#123; Log.d(&quot;aspect&quot;, &quot;afterMethod&quot;);&#125; 来看一下打印日志是这样的12311-12 06:30:52.476 10388-10388/com.jie.aoptest D/aspect: beforeMethod11-12 06:30:52.477 10388-10388/com.jie.aoptest D/login: 请您登录11-12 06:30:52.486 10388-10388/com.jie.aoptest D/aspect: afterMethod 然后我们用around做一个测试123456789101112@Pointcut(&quot;execution(@com.jie.aoptest.aop.CheckLogin * *(..))&quot;)public void methodAnnotated() &#123;&#125;@Around(&quot;methodAnnotated()&quot;)public void aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123; Log.d(&quot;aspect&quot;, &quot;aroundMethod&quot;); Log.d(&quot;login&quot;, &quot;请您登录&quot;); Toast.makeText(App.getAppContext().getCurActivity(), &quot;请您登录&quot;, Toast.LENGTH_SHORT).show(); joinPoint.proceed(); Log.d(&quot;aspect&quot;, &quot;aroundMethod&quot;);&#125; 打印日志是这样的12311-12 06:35:09.696 10512-10512/com.jie.aoptest D/aspect: aroundMethod11-12 06:35:09.696 10512-10512/com.jie.aoptest D/login: 请您登录11-12 06:35:09.700 10512-10512/com.jie.aoptest D/aspect: aroundMethod 两种方式都可以，但要注意一点around和after两种类型是有冲突的，around和before可以共存，所以还是建议两种方式，一种before和after配合使用，一种around单独使用。 参数的获取方法参数的获取方法参数的获取很简单，可以通过joinPoint.getArgs()来获取参数，举个例子： 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... safe(&quot;haha&quot;, 20, true); ...&#125;@Safeprivate void safe(String a, int b, boolean c) &#123; Log.d(&quot;aop&quot;, &quot;获取参数&quot;)&#125; 通知方法1234567@Around(&quot;execution(!synthetic * *(..)) &amp;&amp; methodAnnotated()&quot;)public void aroundJoinPoint(final ProceedingJoinPoint joinPoint) throws Throwable &#123; for (Object arg : joinPoint.getArgs()) &#123; Log.d(&quot;arg&quot;, arg.toString()); &#125; joinPoint.proceed(joinPoint.getArgs());&#125; 日志打印12311-12 06:56:08.062 29915-29915/com.jie.aoptest D/arg: haha11-12 06:56:08.062 29915-29915/com.jie.aoptest D/arg: 2011-12 06:56:08.062 29915-29915/com.jie.aoptest D/arg: true 注解参数的获取直接上代码例子首先需要在注解上声明参数123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface CheckPermission &#123; //声明参数 String declaredPermission();&#125; 然后看一下Activity中的调用方法，注意这里在注解后设置参数值1234@CheckPermission(declaredPermission=&quot;android.permission.READ_PHONE_STATE&quot;)private void checkPhoneState()&#123; Log.d(&quot;CheckPermission&quot;,&quot;Read Phone State succeed&quot;);&#125; 看一下切片类的写法，注意这里在切点上要用@annotation来获取注解对象，然后我们在aroundMethod方法中多了一个checkPermission对象，最后从这个对象中拿到注解参数1234567891011121314@Aspectpublic class CheckPermissionAspect &#123; @Pointcut(&quot;execution(@com.jie.aoptest.aop.CheckPermission * *(..)) &amp;&amp; @annotation(checkPermission)&quot;) public void checkPermission(CheckPermission checkPermission)&#123;&#125;; @Around(&quot;checkPermission(checkPermission)&quot;) public void aroundMethod(JoinPoint joinPoint, CheckPermission checkPermission)&#123; //从注解信息中获取声明的权限。 String neededPermission = checkPermission.declaredPermission(); Log.d(&quot;CheckPermissionAspect&quot;, joinPoint.toShortString()); Log.d(&quot;CheckPermissionAspect&quot;, &quot;\\tneeded permission is &quot; + neededPermission); &#125;&#125; 最后来看一下输出日志，证明我们已经成功拿到注解参数了12311-12 08:00:21.203 24559-24559/com.jie.aoptest D/CheckPermissionAspect: execution(MainActivity.checkPhoneState())11-12 08:00:21.203 24559-24559/com.jie.aoptest D/CheckPermissionAspect: needed permission is android.permission.READ_PHONE_STATE11-12 08:00:21.203 24559-24559/com.jie.aoptest D/CheckPermission: Read Phone State succeed 总结AspectJ解析基本就到这里了，掌握了它就可以全面的用AOP思想去解决问题了，核心还是在解决问题的思路。我也是在边学习边整理从而写出这篇文档，这里讲解了一些AspectJ的基础用法，高级用法大家可以从参考文献的书中去慢慢探索。 参考文献 深入理解Android之AOP 博主写的细致入微，我也从中有所参考。 Manning.AspectJ.in.Action第二版","categories":[{"name":"Android Aop","slug":"Android-Aop","permalink":"http://yoursite.com/categories/Android-Aop/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Android中AOP实践之二场景篇","slug":"Android中AOP实践之二场景篇","date":"2017-11-08T16:00:00.000Z","updated":"2017-11-21T14:02:27.317Z","comments":true,"path":"2017/11/09/Android中AOP实践之二场景篇/","link":"","permalink":"http://yoursite.com/2017/11/09/Android中AOP实践之二场景篇/","excerpt":"上一篇介绍了切面编程AOP的概念，这一篇来讲讲常用的场景，在项目应用中可以分为通用场景和业务场景两种。其中通用场景我用到了日志输出、方法计时、异步操作、异常拦截、动态权限等，业务场景用到了登录验证和单次点击。整个AOP编程是基于aspect实现的，至于实现原理我想放到下一篇再讲。 通用场景日志输出和方法计时 日志这里参考了hugo，JakeWharton大神通过这个项目提供了一个很好的AOP框架。","text":"上一篇介绍了切面编程AOP的概念，这一篇来讲讲常用的场景，在项目应用中可以分为通用场景和业务场景两种。其中通用场景我用到了日志输出、方法计时、异步操作、异常拦截、动态权限等，业务场景用到了登录验证和单次点击。整个AOP编程是基于aspect实现的，至于实现原理我想放到下一篇再讲。 通用场景日志输出和方法计时 日志这里参考了hugo，JakeWharton大神通过这个项目提供了一个很好的AOP框架。 使用方法@DebugLog，可作用于类、构造方法及方法1234567@DebugLogpublic class AopTestActivity extends BaseActivity &#123; @DebugLog public void initView() &#123; ... &#125;&#125; 核心代码1234567891011121314 @Around(&quot;method() || constructor()&quot;) public Object logAndExecute(ProceedingJoinPoint joinPoint) throws Throwable &#123; //进入方法打印日志 enterMethod(joinPoint);//过程计时 long startNanos = System.nanoTime(); Object result = joinPoint.proceed(); long stopNanos = System.nanoTime(); long lengthMillis = TimeUnit.NANOSECONDS.toMillis(stopNanos - startNanos);//离开方法打印日志 exitMethod(joinPoint, result, lengthMillis); return result; &#125; 异步操作异步操作用AOP的好处就是不用每个方法都很复杂的包裹一层异步操作了~ 使用方法12345678@Asyncprivate void async() &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 核心代码异步这里用到了rxjava，如果项目中没有引用rxjava框架可以用异步线程代替~ 12345678910111213141516171819@Around(&quot;execution(!synthetic * *(..)) &amp;&amp; methodAnnotated()&quot;)public void aroundJoinPoint(final ProceedingJoinPoint joinPoint) throws Throwable &#123; Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; Looper.prepare(); try &#123; joinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; Looper.loop(); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe();&#125; ###异常拦截这里指的是可以用注解来暂时性解决方法中异常导致项目崩溃的问题，当然不建议大量滥用。 使用方法1234@Safeprivate void ex() &#123; int a = 10 / 0;&#125; 核心代码12345678910111213141516@Around(&quot;execution(!synthetic * *(..)) &amp;&amp; methodAnnotated()&quot;)public Object aroundJoinPoint(final ProceedingJoinPoint joinPoint) throws Throwable &#123; Object result = null; try &#123; result = joinPoint.proceed(joinPoint.getArgs()); &#125; catch (Throwable e) &#123; LogUtils.e(getStringFromException(e)); &#125; return result;&#125;private static String getStringFromException(Throwable ex) &#123; StringWriter errors = new StringWriter(); ex.printStackTrace(new PrintWriter(errors)); return errors.toString();&#125; 动态权限使用方法核心代码业务场景登录验证这是一种最常用的场景了，点击某个按钮自动检测是否登录，如果没有登录则跳转到登录页面。 使用方法这里编写的AOP注解是支持butterknife的。12345@CheckLogin@OnClick(R.id.btn_login)public void onViewClicked() &#123; ...&#125; 这个业务比较简单，就不贴实现代码了。 单次点击这个场景也比较常见，经常用户点提交性按钮时可能存在连续点击的情况，用这个注解可以及时避免。 使用方法12345@SingleClick@OnClick(R.id.btn_test)public void onViewClicked(View view) &#123; btnTest.setText(&quot;clickNum &quot; + clickNum++);&#125; 核心代码1234567891011121314151617181920212223//viewtagprivate static int TIME_TAG = R.id.click_time;//过滤掉600毫秒内的连续点击private static final int MIN_CLICK_DELAY_TIME = 600;@Pointcut(&quot;execution(@com.app.base.aop.SingleClick * *(..))&quot;)public void methodAnnotated() &#123;&#125;@Around(&quot;methodAnnotated()&quot;)public void aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123; View view = null; for (Object arg : joinPoint.getArgs()) if (arg instanceof View) view = (View) arg; if (view != null) &#123; Object tag = view.getTag(TIME_TAG); long lastClickTime = ((tag != null) ? (long) tag : 0); long currentTime = Calendar.getInstance().getTimeInMillis(); if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) &#123; view.setTag(TIME_TAG, currentTime); joinPoint.proceed(); &#125; &#125;&#125; 以上这些场景基本够项目的日常操作了，通过这些切片也可以节省部分重复劳动，毕竟程序员都是懒惰的嘛。//todo 明天会贴上源码地址","categories":[{"name":"Android Aop","slug":"Android-Aop","permalink":"http://yoursite.com/categories/Android-Aop/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Android中AOP实践一概念篇","slug":"Android中AOP实践一概念篇","date":"2017-11-06T16:00:00.000Z","updated":"2017-11-21T14:02:11.074Z","comments":true,"path":"2017/11/07/Android中AOP实践一概念篇/","link":"","permalink":"http://yoursite.com/2017/11/07/Android中AOP实践一概念篇/","excerpt":"预热在说AOP之前先来说说java最经典的OOP（面向对象编程），我们通过面向对象的封装思想把同一类事物的共性归为一类中，方便我们统一管理。比如我们会把汽车的轮子，发动机，车身喷漆都放在汽车这个类中。这样的好处是良好的封装能够减少耦合，隐藏信息实现细节。但是试想一下如果每个类中有没有重复调用的代码呢？比如日志输出、缓存处理。这里就需要用到AOP思想了。 什么是AOP编程1AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。","text":"预热在说AOP之前先来说说java最经典的OOP（面向对象编程），我们通过面向对象的封装思想把同一类事物的共性归为一类中，方便我们统一管理。比如我们会把汽车的轮子，发动机，车身喷漆都放在汽车这个类中。这样的好处是良好的封装能够减少耦合，隐藏信息实现细节。但是试想一下如果每个类中有没有重复调用的代码呢？比如日志输出、缓存处理。这里就需要用到AOP思想了。 什么是AOP编程1AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 上面是AOP的定义，比较抽象。我们接着上面来说，如果两个类都有做缓存处理，那么我们就需要在两个类中写同样的关于缓存的代码。既然是相同代码那肯定可以做封装嘛，但我们封装一个缓存工具类然后去掉用，上面两个类又和缓存类耦合了。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？ 这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。 AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。 引用知乎上一个图作为补充说明 面向切面，面向方面，也叫刀削面，蘸料是切面，刀削面是切入点，把蘸料加入到刀削面中，就是把切面（要切入的代码段）切入到切入点中去。即AOP。哈哈，我觉得很到位。","categories":[{"name":"Android Aop","slug":"Android-Aop","permalink":"http://yoursite.com/categories/Android-Aop/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Android代码规范","slug":"Android代码规范","date":"2017-05-19T16:00:00.000Z","updated":"2017-11-21T14:02:55.142Z","comments":true,"path":"2017/05/20/Android代码规范/","link":"","permalink":"http://yoursite.com/2017/05/20/Android代码规范/","excerpt":"注释类注释使用文档注释，举例： 12345/** * desc：类名描述，要求简明直译. * author：haojie * date：2017-09-18 */ 方法注释使用文档注释，举例： 12345/** * 方法描述，要求简明直译. * @param xxx 参数名后必须填写说明 * @return xxx 返回值后必须填写说明 */","text":"注释类注释使用文档注释，举例： 12345/** * desc：类名描述，要求简明直译. * author：haojie * date：2017-09-18 */ 方法注释使用文档注释，举例： 12345/** * 方法描述，要求简明直译. * @param xxx 参数名后必须填写说明 * @return xxx 返回值后必须填写说明 */ 类成员变量和常量注释使用单行注释，举例： 12//用户名public static final String USER_ID = \"userId\"; XML注释布局和资源使用xml注释，举例： 12345&lt;!--顶部标题栏--&gt;&lt;include layout=\"@layout/layout_createtheme_titlebar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; gradle注释使用单行注释，举例： 1234//注解框架compile 'com.jakewharton:butterknife:8.4.0'//gsoncompile 'com.google.code.gson:gson:2.2.4' 编码命名包命名包名一律小写，规则为[com].[公司名/组织名].[项目名].[模块名]，举例： 1com.tfedu.yuwen.business 常见的包分层结构 Fragment com.xxx.xxx.fragments 自定义view com.xxx.xxx.view 适配器com.xxx.xxx.adapter 工具com.xxx.xxx.utils 实体com.xxx.xxx.entity 服务com.xxx.xxx.service 广播com.xxx.xxx.receiver 数据库操作com.xxx.xxx.db 类和接口特定的命名 Activity xxxActivity Fragment xxxFragment AdapterxxxAdapter ServicexxxService BroadcastReceiverxxxReceiver ContentProviderxxxProvider 数据库类xxxDBHelper 解析类xxxParser 自定义共享基类BaseXxx 工具类xxxUtil``xxxManager HandlerxxxHandler 实体类xxxEntity 自定义viewxxxView 方法以动词或动名词命名，采用驼峰命名法 常见的命名场景 初始化相关方法，使用init为前缀标识，如初始化布局initViewinitXxx() 返回值为boolean类型的方法使用is前缀isXx() 返回某个值的方法，使用get为前缀getXxx() 对数据进行处理的方法，统一使用process为前缀processXxx() 弹出提示信息或者提示框，使用display作为前缀displayXxx() 保存数据相关的，使用save前缀saveXxx() 对数据重组的，使用reset前缀resetXxx() 清除数据的情况，使用clear前缀clearXxx() 删除控件的情况，使用remove前缀removeXxx() 绘制数据或效果相关的，使用draw为前缀drawXxx() 请求网络数据的，统一使用request为前缀requestXxx() 显示某布局的情况，使用show为统一前缀showXxx() 变量及常量参考java编码规则中的定义 资源命名layout布局 Activity布局 项目中所有Activity页面对应的布局均采用activity前缀 + 模块或者页面对应的英文名称,布局中所有的均采用小写字母。举例：12//创建主题布局activity_createtheme.xml Fragment布局项目中所有Fragment页面对应的布局均采用fragment前缀 + 模块或者页面对应的英文名称,布局中所有的均采用小写字母。举例： 12//讨论列表布局fragment_discusslist.xml 公共被引用layout布局中的共用布局片段抽取采用layout前缀+模块+功能名称。举例： 12//评论模块音频片段layout_comment_audio.xml 4.列表中的item项目中列表页面中的item采用item前缀+页面名称。举例：12//讨论列表itemitem_discuss.xml 空数据页面项目中列表页面的空数据页面采用empty前缀+页面名称。举例： 12//空数据页面empty_message.xml 自定义控件（组合布局）项目中自定义控件引用布局比如加载输入框布局采用view前缀+布局名称。举例： 12//加载输入框样式view_loading.xml drawable资源 selector类型项目中点击选中状态采用drawable前缀+使用selector前缀+页面名称+事件。举例： 12//返回键选中状态事件selector_discuss_back.xml shape类型项目中图形绘制命名采用shape前缀+使用场景名称+控件类型。举例： 12//学科按钮图形shape_subject_btn.xml values资源 attrs属性资源项目中自定义view属性资源父级命名采用大写开头驼峰形式的控件名称命名，内部属性采用小写开头驼峰形式的属性名称命名。举例： 12345&lt;!--下拉控件属性--&gt;&lt;declare-styleable name=\"DropDownMenu\"&gt; &lt;attr name=\"underlineColor\" format=\"color\"/&gt; &lt;attr name=\"dividerColor\" format=\"color\"/&gt;&lt;/declare-styleable&gt; colors颜色资源项目中颜色资源采用color+颜色值小写的形式命名，value值也均采用小写。举例： 12&lt;color name=&quot;color_ffffff&quot;&gt;#ffffff&lt;/color&gt;&lt;color name=&quot;color_f6f6f6&quot;&gt;#f6f6f6&lt;/color&gt; string文字资源 公共文字资源采用直接文字描述对应的英文名称。举例： 12&lt;string name=&quot;theme&quot;&gt;[主题讨论]&lt;/string&gt;&lt;string name=&quot;writing&quot;&gt;[写作]&lt;/string&gt; 页面或组件特定的文字资源采用模块名称+英文名称。举例： 12&lt;string name=&quot;comment_hint&quot;&gt;输入点评内容&lt;/string&gt;&lt;string name=&quot;comment_success&quot;&gt;发布成功！&lt;/string&gt; 如果有不固定内容采用占位符占位的形式。举例： 1&lt;string name=&quot;discuss_speicial&quot;&gt;%1$s专题&lt;/string&gt; styles样式资源项目中样式资源父级命名采用大写开头驼峰形式的控件名称命名，内部属性采用小写开头驼峰形式的属性名称命名。举例： 12345&lt;!-- 首页tablayout样式--&gt; &lt;style name=\"MainTabLayout\" parent=\"Widget.Design.TabLayout\"&gt; &lt;item name=\"tabIndicatorColor\"&gt;@color/color_f6f6f6&lt;/item&gt; &lt;item name=\"tabBackground\"&gt;?attr/selectableItemBackground&lt;/item&gt;&lt;/style&gt; mipmap图片资源图片资源以特定的方式命名以后有很多好处，见名知意、方便查找、避免重复等等。图片建议全部使用png格式为标准。 公用页面采用common+图片的功能名称+事件状态组合。举例： 1common_back_pre.png 页面中图片命名采用页面英文名称+图片功能名称+事件状态组合。举例： 1discuss_publish_disable.png 常见的事件状态后缀 普通状态nor 按下状态pre 选中状态sel 未选中状态unsel 不可用状态disable 聚焦状态focus 布局中常用控件缩写 TextViewtv EditTextet ImageViewiv Buttonbtn CheckBoxcb RadioButtonrb ProgressBarpb RatingBarrat LinearLayoutll RelativeLayoutrl TableLayouttl FrameLayoutfl ScrollViewsv HorizontalScrollViewhsv TabLayouttl CardViewcv GridLayoutgl RecyclerViewrv java编码规约命名规约普通变量命名采用java命名规范，统一采用驼峰命名法 代码中命名均不能以下划线或美元符号开始，也不能以下划线或者美元符号结束。 代码中的命名严禁使用拼音和英文混合的方式，更不允许世界使用中文的方式。 方法明、参数名、成员变量、局部变量都统一使用lowerCamelCase,必须遵从驼峰形式。 常量命名全部大写，单词间用下划线隔开，力求语意表达完整清楚，不要嫌名字长。 中括号是数组类型的一部分，数组定义如下：String[] args; 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它的名称开始，以Test结尾。 杜绝完全不规范的缩写，避免望文不知义。 如果使用到了设计模式，建议在类名中体现出具体模式。[例子：public class OrderFactory; public class LoginProxy; public class ResourceObserver;]常量定义常量定义在Android开发中非常常见，通常情况下公用的常量都写到常量工具类中 utils包中的Constant类中。如果是某个类中特有的常量，都写在这个特定的类中,命名时不建议使用缩写。公共常量的名字是注释的直译，以下划线隔开。特定类中的相同类型的常量最好有统一的前缀。 公共类型常量。举例： 12//发布类型 public static final String PUBLISH_TYPE = “public_type”; 特定类中的一系列常量。如果只有当前类使用请用private描述。举例： 1234//状态可用private static final int STATUS_ENABLE = 0;//状态不可用private static final int STATUS_DISABLE = 1; 格式规约 统一使用AndroidStudio格式化工具进行格式化 统一使用AndroidStudio的Inspection工具进行检查校验OOP规约 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 所有的覆写方法，必须加@Override注解。 相同的参数类型，相同的业务含义，才可以使用Java的可变参数，避免使用Object,可以变参数必须放在参数列表的最后。场景：一堆控件的显示和隐藏控制 Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 构造方法里面禁止加入任何业务逻辑，如果有初始化的逻辑，请放在init方法中。 循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。 final可提高程序响应的效率，声明成final的情况： 不需要重新赋值的变量，包括类属性、局部变量 对象参数前加final，表示不允许修改引用的指向。 类方法确定不允许被重新。 类成员与方法访问控制从严。【建议】 如果不允许外部直接通过new来创建对象，那么构造方法必须是private. 工具类不允许有public或default构造方法。 类非static成员变量并且与子类共享，必须是protected. 类非static成员变量并且仅在本类使用，必须是private。 类static成员变量如果仅在本类使用，必须是private. 若是static成员变量，必须考虑是否为final。 类成员方法只供类内部调用，必须是private。 类成员方法只对继承类公开，那么限制为protected.android编码规约【强制】 代码中注释以外地方不要出现中文，可以通过strings.xml引用来显示中文 控件的声明要放在activity和fragment级别，以便在整个界面使用 每个界面的点击事件统一在一个方法中处理；不在xml中添加事件 strings.xml中使用%1sd等实现字符串的通配 界面中的数据传递避免使用全局变量 数据类型转换要进行校验 使用常量代替枚举 业务复杂的地方，可以抽取组件或者工具类；如果通用可以写到BaseActivity或者BaseFragment中 类注释必须添加 分层","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"}]}]}